#pragma once

#include "util.h"
#include "materials.h"

struct Sphere {
    Vec3 center;
    float_T radius;
    Material material;

    Sphere(Vec3 center, float_T radius, Material material)
        : center(center), radius(radius), material(std::move(material)){ }

    std::optional<Intersection> intersect(const Ray& ray) const {
        // mostly generated by ai

        // Vector from the ray's origin to the sphere's center
        Vec3 oc = ray.origin - center;

        // Coefficients of the quadratic equation (a*t^2 + b*t + c = 0)
        float_T a = ray.direction.dot(ray.direction);               // a = D•D
        float_T b = 2.0 * oc.dot(ray.direction);                    // b = 2 * oc•D
        float_T c = oc.dot(oc) - radius * radius;                   // c = (oc•oc - r^2)

        // Discriminant of the quadratic equation
        float_T discriminant = b * b - 4 * a * c;

        // No intersection if the discriminant is negative
        if (discriminant < 0) {
            return std::nullopt;
        }

        // Calculate the two intersection distances along the ray
        float_T sqrtDiscriminant = std::sqrt(discriminant);
        float_T t1 = (-b - sqrtDiscriminant) / (2.0 * a);
        float_T t2 = (-b + sqrtDiscriminant) / (2.0 * a);


        // Choose the closest intersection point in front of the ray origin
        float_T t = (t1 > 0) ? t1 : ((t2 > 0) ? t2 : -1);
        // if both are behind the ray, return no intersection
        if (t < 0) {
            return std::nullopt;
        }

        // Calculate intersection details
        Vec3 intersectionPoint = ray.origin + ray.direction * t;
        Vec3 intersectionNormal = (intersectionPoint - center).normalized();

        // Calculate texture coordinates
        Vec3 localPoint = (intersectionPoint - center) / radius; // Normalize to unit sphere

        // Calculate spherical coordinates
        float_T theta = std::atan2(localPoint.z, localPoint.x); // Longitude
        float_T phi = std::acos(localPoint.y);                  // Latitude

        // Map spherical coordinates to texture coordinates (u, v)
        float_T u = (theta + PI) / (2 * PI);
        float_T v = phi / PI;

        return Intersection(&ray, std::move(intersectionPoint), std::move(intersectionNormal), &material, Vec2(u, v));
    }

    /// equality (explicitly do not check for material, because two spheres with the exact same position and geometry should not have different materials; this is the same for all other shapes)
    bool operator==(const Sphere& other) const {
        return center == other.center && radius == other.radius;
    }
}; // end struct Sphere

struct Cylinder {
    Vec3 center;
    float_T radius;
    float_T eachSideHeight;
    Vec3 axis;
    Material material;

    // stretch the textures at the side of the 
    float_T textureSideStretchFactor;
    float_T textureCapScale;

    Cylinder(Vec3 center, float_T radius, float_T height, Vec3 axis, Material material, float_T textureSideStretchFactor = 1.0, float_T textureCapScale = 1.0)
        : center(center), radius(radius), eachSideHeight(height), axis(axis), material(std::move(material)), textureSideStretchFactor(textureSideStretchFactor), textureCapScale(textureCapScale) {  }

    std::optional<Intersection> intersect(const Ray& ray) const {
        // mostly generated by ai

        Vec3 d = ray.direction - axis * ray.direction.dot(axis);  // Projected ray direction onto the cylinder's plane
        Vec3 oc = ray.origin - center;
        Vec3 oc_proj = oc - axis * oc.dot(axis);                  // Projected ray origin onto the cylinder's plane

        float_T a = d.dot(d);
        float_T b = 2. * d.dot(oc_proj);
        float_T c = oc_proj.dot(oc_proj) - radius * radius;
        std::optional<Intersection> closestIntersection = std::nullopt;

        // Quadratic discriminant for side wall intersection
        float_T discriminant = b * b - 4 * a * c;
        if (discriminant >= 0) {
            float_T sqrtDiscriminant = std::sqrt(discriminant);
            for (float_T t : { (-b - sqrtDiscriminant) / (2.0 * a), (-b + sqrtDiscriminant) / (2.0 * a) }) {
                if (t < 0) continue;

                Vec3 point = ray.origin + ray.direction * t;
                Vec3 localPoint = point - center;
                float_T projectionOnAxis = localPoint.dot(axis);

                // Check if intersection point is within height limits of the cylinder
                if (projectionOnAxis >= -eachSideHeight && projectionOnAxis <= eachSideHeight) {
                    Vec3 normal = (localPoint - axis * projectionOnAxis).normalized();
                    Intersection intersection(&ray, point, normal, &material, textCoordsOfSideIntersection(point));


                    // Update closest intersection
                    if (!closestIntersection || t < (closestIntersection->point - ray.origin).length()) {
                        closestIntersection = intersection;
                    }
                }
            }
        }

        auto checkCapIntersection = [&](const Vec3& capCenter, const Vec3& capNormal) -> std::optional<Intersection> {
            float_T denom = ray.direction.dot(capNormal);
            if (std::abs(denom) < 1e-6) return std::nullopt;

            float_T tCap = (capCenter - ray.origin).dot(capNormal) / denom;
            if (tCap < 0) return std::nullopt;

            Vec3 point = ray.origin + ray.direction * tCap;
            if ((point - capCenter).length() <= radius) {  // Check if within radius of cap
                Intersection intersection(&ray, point, capNormal, &material, textCoordsOfCapIntersection(point));
                return intersection;
            }
            return std::nullopt;
        };

        // Check intersections with the base and top caps
        for (auto& cap : { std::make_pair(center - axis * eachSideHeight, -axis), 
                std::make_pair(center + axis * eachSideHeight, axis) }) {
            if (auto capIntersection = checkCapIntersection(cap.first, cap.second); capIntersection) {
                float_T capDistance = (capIntersection->point - ray.origin).length();
                if (!closestIntersection || capDistance < (closestIntersection->point - ray.origin).length()) {
                    closestIntersection = capIntersection;
                }
            }
        }

        return closestIntersection;
    }

    bool operator==(const Cylinder& other) const {
        return center == other.center && radius == other.radius && eachSideHeight == other.eachSideHeight && axis == other.axis;
    }

private:
    Vec2 textCoordsOfSideIntersection(const Vec3& intersectionPoint) const {
        Vec3 baseToIntersection = intersectionPoint - (center - axis * eachSideHeight);
        float_T vPosAlongAxis = baseToIntersection.dot(axis);        
        float_T v = vPosAlongAxis / (2 * eachSideHeight * textureSideStretchFactor);  // Map height position to v in [0, 1], then stretch



        Vec3 circumferentialDir = (baseToIntersection - axis * vPosAlongAxis).normalized();
        float_T theta = std::atan2(circumferentialDir.z, circumferentialDir.x);        
        float_T u = (theta + PI) / (2 * PI);  // Map angle to u in [0, 1]

        return Vec2(u,v);
    }

    Vec2 textCoordsOfCapIntersection(const Vec3& intersectionPoint) const {
        // Determine which cap (top or bottom) we're on based on axis direction and height
        Vec3 capCenter = intersectionPoint.dot(axis) > 0 ? (center + axis * eachSideHeight) : (center - axis * eachSideHeight);
        Vec3 localCapPoint = intersectionPoint - capCenter;

        // Map `localCapPoint` to polar coordinates within the cap radius
        float_T r = localCapPoint.length() / radius;  // Distance from center mapped to [0, 1]
        float_T capTheta = std::atan2(localCapPoint.z, localCapPoint.x);

        float_T u = 0.5 + r * std::cos(capTheta) / 2;  // Map radial distance and angle to texture u
        float_T v = 0.5 + r * std::sin(capTheta) / 2;  // Map radial distance and angle to texture v

        return Vec2(u,v) / textureCapScale;
    }
}; // end struct Cylinder

template<bool hasVertexNormals>
struct Triangle {
    Vec3 v0,v1,v2;
    // NOTE: could deduplicate materials for triangle objects later on, for big meshes that all have the same material
    Material material;
    // these are only valid if the material has a texture
    Vec2 v0TexCoord, v1TexCoord, v2TexCoord;

    // NOTE: could precompute bounding box or mins/maxes for faster building of the BVH

    // depending on the template parameter either store a single normal for the whole face or one for each vertex
    struct VertexNormals{
        Vec3 v0Normal, v1Normal, v2Normal;
    };
    std::conditional_t<!hasVertexNormals,
        // normal that's constant across the face
        Vec3,
        // normal for each vertex
        VertexNormals
    > normalInfo;

    Triangle(Vec3 v0, Vec3 v1, Vec3 v2, Material material, Vec2 v0TexCoord, Vec2 v1TexCoord, Vec2 v2TexCoord)
        requires(!hasVertexNormals)
        : v0(v0), v1(v1), v2(v2), material(std::move(material)), v0TexCoord(v0TexCoord), v1TexCoord(v1TexCoord), v2TexCoord(v2TexCoord),
            normalInfo((v1 - v0).cross(v2 - v0).normalized()) { }

    Triangle(Vec3 v0, Vec3 v1, Vec3 v2, Material material, Vec2 v0TexCoord, Vec2 v1TexCoord, Vec2 v2TexCoord, VertexNormals vertexNormals)
        requires(hasVertexNormals)
        : v0(v0), v1(v1), v2(v2), material(std::move(material)), v0TexCoord(v0TexCoord), v1TexCoord(v1TexCoord), v2TexCoord(v2TexCoord),normalInfo(vertexNormals){ }

    std::optional<Intersection> intersect(const Ray& ray) const {
        // Möller–Trumbore intersection
        // mostly generated by ai
        Vec3 edge1 = v1 - v0;
        Vec3 edge2 = v2 - v0;
        Vec3 h = ray.direction.cross(edge2);
        float_T a = edge1.dot(h);

        // If a is near zero, the ray is parallel to the triangle
        if (std::abs(a) < epsilon) return std::nullopt;

        float_T f = 1.0 / a;
        Vec3 s = ray.origin - v0;
        float_T u = f * s.dot(h);

        // Check if the intersection is outside the triangle
        if (u < 0.0 || u > 1.0) return std::nullopt;

        Vec3 q = s.cross(edge1);
        float_T v = f * ray.direction.dot(q);

        // Check if the intersection is outside the triangle
        if (v < 0.0 || u + v > 1.0) return std::nullopt;

        // Calculate the distance along the ray to the intersection point
        float_T t = f * edge2.dot(q);

        // Only accept intersections that are in front of the ray origin
        if (t > epsilon) {
            Vec3 intersectionPoint = ray.origin + ray.direction * t;

            // interpolate texture coordinates
            // calculate barycentric coordinate `w`
            float_T w = 1. - u - v;

            // interpolate the texture coordinates using barycentric weights
            Vec2 interpolatedTexCoord = v0TexCoord * w + v1TexCoord * u + v2TexCoord * v;

            Vec3 normal;
            if constexpr(!hasVertexNormals){
                // in this case, the normalInfo just holds the face normal
                normal = normalInfo;
            }else{
                // in this case, the normalInfo holds the normals for each vertex
                // -> interpolate the normals using barycentric coordinates (can reuse them from the texture coordinate calculation)
                normal = (normalInfo.v0Normal * w + normalInfo.v1Normal * u + normalInfo.v2Normal * v).normalized();
            }

            // ensure the normal points against the ray's direction,
            // we want to make sure that backfaces look like frontfaces
            if (normal.dot(ray.direction) > 0) {
                normal = -normal;
            }

            return Intersection(&ray, intersectionPoint, normal, &material, interpolatedTexCoord);
        }

        return std::nullopt;
    }
    
    bool operator==(const Triangle<hasVertexNormals>& other) const{
        return v0 == other.v0 && v1 == other.v1 && v2 == other.v2;
    }
}; // end struct Triangle

// separating out both types
// - avoids checking which type the triangle is for every intersection at runtime, thus improves performance
//      - these checks are moved to the std::visit which is more efficient and better for branch prediction
// - (if we used indirections instead of std variant would reduce memory usage)
using TriangleWithVertexNormals = Triangle<true>;
using TriangleWithConstantFaceNormal = Triangle<false>;

struct SceneObject {
    // use a variant to store different types of objects, to avoid virtual function calls (expensive)
    std::variant<TriangleWithVertexNormals, TriangleWithConstantFaceNormal, Sphere, Cylinder> variant;

    std::optional<Intersection> intersect(const Ray& ray) const {
        return std::visit([&](auto&& object){
            return object.intersect(ray);
        }, variant);
    }

    bool operator==(const SceneObject& other) const{
        return variant == other.variant;
    }
};

struct BoundingBox{
    Vec3 min, max;

    BoundingBox() :
          min(Vec3(std::numeric_limits<float_T>::max()))
        , max(Vec3(-std::numeric_limits<float_T>::max())) 
    { }

    /// assumes min and max are actually <= each other, componentwise
    BoundingBox(Vec3 min, Vec3 max)
        : min(min), max(max){
        assert(min.x <= max.x && min.y <= max.y && min.z <= max.z && "Trying to construct invalid bounding box");
    }

    explicit BoundingBox(SceneObject object) {
        std::visit([this](auto&& object){
            using T = std::decay_t<decltype(object)>;
            if constexpr(std::is_same_v<T, TriangleWithVertexNormals> || std::is_same_v<T, TriangleWithConstantFaceNormal>){
                min = Vec3(
                    std::min({object.v0.x, object.v1.x, object.v2.x}),
                    std::min({object.v0.y, object.v1.y, object.v2.y}),
                    std::min({object.v0.z, object.v1.z, object.v2.z})
                );
                max = Vec3(
                    std::max({object.v0.x, object.v1.x, object.v2.x}),
                    std::max({object.v0.y, object.v1.y, object.v2.y}),
                    std::max({object.v0.z, object.v1.z, object.v2.z})
                );
            }else if constexpr(std::is_same_v<T, Sphere>){
                min = object.center - Vec3(object.radius);
                max = object.center + Vec3(object.radius);
            }else if constexpr(std::is_same_v<T, Cylinder>){
                // cylinder can be encompassed in a box with one corner at one side of the bottom cap, and the other at the other side of the top cap
                const Vec3 bottomCapCenter = object.center - object.axis * object.eachSideHeight;
                const Vec3 topCapCenter = object.center + object.axis * object.eachSideHeight;

                // we'll be shifting points along the 2 "cap" axes (by the radius), so mask out the "height" axis of the cylinder
                const Vec3 axisMask = Vec3(1.) - object.axis;
                // and then invert the axis for one corner, and use it directly for the other
                const Vec3 bottomCapCorner = bottomCapCenter - axisMask * Vec3(object.radius);
                const Vec3 topCapOppositeCorner = topCapCenter + axisMask * Vec3(object.radius);

                min = bottomCapCorner;
                max = topCapOppositeCorner;
            }else{
                static_assert(false, "Unexpected object type");
            }
        }, object.variant);
        assert(min.x <= max.x && min.y <= max.y && min.z <= max.z && "Internal error: invalid bounding box constructed");
    }

    Vec3 center() const { 
        return (min + max) * 0.5; 
    }

    Vec3 extent() const { 
        return max - min; 
    }

    BoundingBox merge(const BoundingBox& other) const {
        return BoundingBox(
            min.min(other.min),
            max.max(other.max)
        );
    }

    bool contains(const Vec3& point) const {
        return point.x >= min.x && point.x <= max.x &&
               point.y >= min.y && point.y <= max.y &&
               point.z >= min.z && point.z <= max.z;
    }

    bool intersects(const Ray& ray) const {
        Vec3 invDir = Vec3(1.) / ray.direction;
        
        Vec3 t0 = (min - ray.origin) * invDir;
        Vec3 t1 = (max - ray.origin) * invDir;
        
        Vec3 tmin = t0.min(t1);
        Vec3 tmax = t0.max(t1);
        
        float_T tenter = std::max(std::max(tmin.x, tmin.y), tmin.z);
        float_T texit = std::min(std::min(tmax.x, tmax.y), tmax.z);
        
        return tenter <= texit && texit >= 0;
    }

    bool overlaps(const BoundingBox& other) const {
        return min.x <= other.max.x && max.x >= other.min.x &&
               min.y <= other.max.y && max.y >= other.min.y &&
               min.z <= other.max.z && max.z >= other.min.z;
    }

    float_T surface_area() const {
        Vec3 d = extent();
        return 2. * (d.x * d.y + d.y * d.z + d.z * d.x);
    }
}; // end struct BoundingBox

/// bounding volume hierarchy
struct BVHNode{
    struct ObjectRange{
        /// left-inclusive, right-exclusive
        std::pair<size_t, size_t> objectRange;

        // allow implicit conversion
        ObjectRange(std::pair<size_t, size_t> objectRange)
            : objectRange(objectRange){ }

        ObjectRange(size_t first, size_t last)
            : objectRange(std::make_pair(first, last)){ }

        size_t size() const{
            return objectRange.second - objectRange.first;
        }

        bool empty() const{
            return objectRange.first == objectRange.second;
        }

        bool operator==(const ObjectRange& other) const{
            return objectRange == other.objectRange;
        }

        size_t begin() const{
            return objectRange.first;
        }

        size_t end() const{
            return objectRange.second;
        }

        // implicit conversion to pair
        operator std::pair<size_t, size_t>() const{
            return objectRange;
        }
    };

    BoundingBox bounds;
    std::unique_ptr<BVHNode> left, right;
    /// range of objects in the scene object list that this node represents
    ObjectRange objectRange;

    // this limits the memory usage of the BVH to 2^16*sizeof(BVHNode) ~= 3.3 MB
    // in practice, it may very well be advisable to increase this, as the performance improvements of having almsot every object in its own leaf node are substantial
    static constexpr size_t MAX_DEPTH = 16;
    // NOTE: I experimented with a MIN_OBJECTS value for the leaf nodes, but it is not currently in use, because even though it reduces memory usage, it reduces performance improve performance
    //static constexpr size_t MIN_OBJECTS = 4;

public:
    /// REORDERS THE OBJECTS VECTOR
    /// but does not store it anywhere, the objects explicitly live outside the BVH
    BVHNode(ObjectRange objectRangeP, std::vector<SceneObject>& objects, uint32_t depth = 0) 
        : objectRange(std::move(objectRangeP))
    {
        assert(objectRange.begin() <= objectRange.end() && "Invalid objectRange");
        assert(objectRange.end() <= objects.size() && "objectRange exceeds object vector");

        // get the maximum bounds of all objects in the range
        bounds = boundsFromObjectRange(objectRange, objects);
        
        if (depth >= MAX_DEPTH)
            return;

        // Find the axis with greatest extent, to be able to subdivide as equally as possible
        Vec3 extent = bounds.extent();
        int splitAxis = 0;
        if (extent.y > extent.x) splitAxis = 1;
        if (extent.z > extent[splitAxis]) splitAxis = 2;

        // idea of partitioning via centroids by ai

        // partition objects along the median of the split axis
        auto begin = objects.begin() + objectRange.begin();
        auto end = objects.begin() + objectRange.end();
        std::nth_element(begin, begin + (end - begin)/2, end,
            [splitAxis](const SceneObject& a, const SceneObject& b) {
                return computeCentroid(a)[splitAxis] < computeCentroid(b)[splitAxis];
            }
        );
        size_t midIndex = objectRange.begin() + (objectRange.end() - objectRange.begin()) / 2;
        
        // only create children if there are actually objects in the range
        if (midIndex > objectRange.begin() && midIndex < objectRange.end()) {
            left = std::make_unique<BVHNode>(ObjectRange(objectRange.begin(), midIndex), objects, depth + 1);
            right = std::make_unique<BVHNode>(ObjectRange(midIndex, objectRange.end()), objects, depth + 1);
        }
    }

    std::optional<Intersection> intersect(const Ray& ray, const std::vector<SceneObject>& objects) const {
        if (!bounds.intersects(ray))
            return std::nullopt;

        if (isLeaf()) {
            auto closestIntersection = std::optional<Intersection>();

            for (auto i = objectRange.begin(); i < objectRange.end(); ++i)
                if (auto intersection = objects[i].intersect(ray))
                    if(!closestIntersection.has_value() || intersection->distance() < closestIntersection->distance())
                        closestIntersection = *intersection;

            return closestIntersection;
        }

        // here, we're just checking both boxes

        // sidenote: but we could check the least number of nodes by:
        // a checking the closer box first
        // b only checking the other box if the boxes overlap, or if the closer box has no intersection
        // (THIS IS NOT IMPLEMENTED HERE)

        auto leftIntersection = left->intersect(ray, objects);
        auto rightIntersection = right->intersect(ray, objects);
        if(leftIntersection.has_value() && rightIntersection.has_value())
            return leftIntersection->distance() < rightIntersection->distance() ? leftIntersection : rightIntersection;
        else if(leftIntersection.has_value())
            // don't std::move this, to allow copy elision
            return leftIntersection;
        else
            // if the right intersection is empty, this will also return nullopt
            return rightIntersection;
    }

    bool isLeaf() const { 
        return !left && !right; 
    }

    // === The following public methods are all for debugging purposes ===

    void verifyBVH(const std::vector<SceneObject>& objects) const {
#ifdef NDEBUG
        std::println(stderr, "verifyBVH should only be called in debug mode");
        std::abort();
#endif
        // Verify range validity
        assert(objectRange.begin() <= objectRange.end() && "Invalid objectRange");
        assert(objectRange.end() <= objects.size() && "objectRange exceeds vector size");

        if (!isLeaf()) {
            // Verify children exist
            // (this is a bit stupid, because isLeaf would prob fail first, but just in case)
            assert(left && right && "Non-leaf node missing children");

            // Recursively verify children
            left->verifyBVH(objects);
            right->verifyBVH(objects);

            // Verify child objectRanges overlap linearly, i.e.
        }
    }

    void recursivelyCollectIntersectedBoxes(const Ray& ray, std::vector<std::pair<BoundingBox, int>>& boxes, int depth = 0) const {
        if (bounds.intersects(ray)) {
            boxes.push_back({bounds, depth});
            
            if (!isLeaf()) {
                left->recursivelyCollectIntersectedBoxes(ray, boxes, depth + 1);
                right->recursivelyCollectIntersectedBoxes(ray, boxes, depth + 1);
            }
        }
    }

    uint64_t numNodes() const {
        if (isLeaf())
            return 1;
        return 1 + left->numNodes() + right->numNodes();
    }

private:
    static Vec3 computeCentroid(const SceneObject& object) {
        // partially generated by ai
        return std::visit([](const auto& obj) -> Vec3 {
            using T = std::decay_t<decltype(obj)>;
            if constexpr (std::is_same_v<T, TriangleWithVertexNormals> || std::is_same_v<T, TriangleWithConstantFaceNormal>){
                return (obj.v0 + obj.v1 + obj.v2) / 3.;
            } else if constexpr (std::is_same_v<T, Sphere>) {
                return obj.center;
            } else if constexpr (std::is_same_v<T, Cylinder>) {
                return obj.center;
            } else{
                static_assert(false, "Unexpected object type");
            }
        }, object.variant);
    }

    static BoundingBox boundsFromObjectRange(ObjectRange range, 
                                    const std::vector<SceneObject>& objects) {
        BoundingBox bounds;
        for (size_t i = range.begin(); i < range.end(); ++i) {
            bounds = bounds.merge(BoundingBox(objects[i]));
        }
        return bounds;
    }
}; // end struct BVHNode
